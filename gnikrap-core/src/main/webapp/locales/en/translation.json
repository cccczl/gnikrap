{
  "@comment": "English translation (also used as default translation)",

  "navigationBar": {
    "run": "Run",
    "stop": "Stop",
    "gnikrap": {
      "about": "About...",
      "fullScreen": "Toggle full screen",
      "stopGnikrap": "Stop Gnikrap...",
      "settings": "Settings...",
      "importImages": "Import images...",
      "documentation": "Documentation..."
    },

    "confirmStopGnikrap": {
      "title": "Stop Gnikrap",
      "message": "Do you want to stop Gnikrap (and return to the 'brick menu') or to stop the brick?",
      "cancel": "No, does nothing",
      "stopGnikrap": "Yes, stop Gnikrap",
      "shutdownBrick": "Yes, shutdown the brick"
    }
  },


  "workArea": {
    "@comment": "The list of the work area available",
    "scriptEditorTab": "Script editor",
    "keyboardSensorTab": "xTouch",
    "videoSensorTab": "xVideo",
    "gyroSensorTab": "xGyroscope",
    "geoSensorTab": "xGeo"
  },


  "messageLog": {
    "clear": "Clear",
    "keepLast": "Keep last messages only"
  },


  "scriptEditorTab": {
    "clear": "Clear",
    "loadAndManage": "Load/Manage",
    "save": "Save",
    "viewJavaScript": "View JavaScript",

    "loadingScripWait": "// Loading script: '__filename__', please wait...",
    "scriptSuccessfullySaved": "Script '__filename__' successfully saved",

    "demo": {
      "no_load": "Demo mode, cannot load file",
      "no_save": "Demo mode, cannot save file"
    },

    "errors": {
      "cantLoadScriptFile": "Can't load '__filename__' script file. [__causedBy__]",
      "cantSaveScriptFile": "Can't save '__filename__' script file. [__causedBy__]"
    },

    "saveScriptModal": {
      "title": "Save the script with the following name:"
    },

    "clearScriptModal": {
      "title": "Are you sure to clear the current script ?"
    },
    
    "fixGenikrapErrorModal": {
      "title": "Please fix errors (see on the notification part for more details)"
    }
  },


  "keyboardSensorTab": {
    "sensorName": "Name",
    "start": "Start",
    "clear": "Clear",
    "loadAndManage": "Load/Manage",
    "save": "Save",

    "keyboardSuccessfullySaved": "Keyboard '__filename__' successfully saved",
    
    "configureKeyboardButtonModal": {
      "title": "Enter the name(s) of the button (use the comma to separate several names)"
    },

    "resetKeyboardModal": {
      "title": "Are you sure to clear the current xTouch configuration ?"
    },

    "saveKeyboardModal": {
      "title": "Save the keyboard with the following name:"
    },
    
    "errors": {
      "cantLoadKeyboardFile": "Can't load '__filename__' keyboard file. [__causedBy__]",
      "cantSaveKeyboardFile": "Can't save '__filename__' keyboard file. [__causedBy__]"
    }
  },


  "gyroSensorTab": {
    "start": "Start",
    "setAxis": "Device orientation",
    "xAxis": "x is the front-back tilt in degrees where front is positive (also known as 'beta' with 'Portrait' orientation)",
    "yAxis": "y is the left-right tilt in degrees, where right is positive (also known as 'gamma' with 'Portrait' orientation)",
    "zAxis": "z is the compass direction of the device in degrees (also known as 'alpha')",
    "zAxisNote": "Note: Some devices don't support compass (the z value will always be 0). For some devices, the compass don't returns the angle with the north.",

    "axisOrientation": {
      "o0": "Portrait (default)",
      "o90": "Landscape left",
      "o-90": "Landscape right",
      "o180": "Reverse portrait"
    },

    "setAxisDialogLight": {
      "title": "Set device orientation",
      "message": "Orientation has been detected to: '__axisOrientation__'",
      "cancel": "Cancel",
      "ok": "Accept",
      "fullChoice": "Other orientation..."
    },

    "setAxisDialogFull": {
      "title": "Set device orientation",
      "message": "Select the orientation of your device in order to have expected values. The default orientation is 'Portrait', in general it's when the power cord is at the bottom of your device.",
      "cancel": "Cancel",
      "landscapeLeft": "Landscape left",
      "landscapeRight": "Landscape right",
      "portrait": "Portrait",
      "reversePortrait": "Reverse portrait"
    }
  },


  "videoSensorTab": {
    "start": "Start",
    "addPoints": "Click on the video to add objects to track",

    "newPoint": "Object-",
    "pointsNoMoreTracked": "The object '__name__' has been lost, it will no more be tracked",

    "errors": {
      "maximumTrackedPointsReached": "The maximum number of object to track (__number__) has been reached",
      "videoAccessRefused": "Error while accessing to the webcam"
    },

    "configureTrackedPointNameModal": {
      "title": "Enter the name of the object to track"
    }
  },


  "geoSensorTab": {
    "start": "Start",

    "latitude": "Latitude is the north-south position of a point on the Earth's surface (0째 for equator, +90째 for north pole, -90째 for south pole).",
    "longitude": "Longitude is the east-west position of a point on the Earth's surface (0째 for Greenwich meridian).",
    "accuracy": "The accuracy (in meter) of the latitude and longitude.",
    "altitude": "The altitude (in metter) from the see level (Some devices don't support altitude, the value will always be 0).",
    "altitudeAccuracy": "The accuracy (in meter) of the altitude (Some devices don't support altitude, the value will always be 0).",
    "timestamp": "The timestamp (date and time) where the geolocation has been done.",

    "errors": {
      "timeout": "The geolocation is too slow (__detail__)",
      "permissionDenied": "You should accept geolocation in order to have the xGeo sensor working (__detail__)",
      "positionUnavailable": "There is an internal problem during the geolocation (__detail__)",
      "unknownError": "Error while using the geolocation (__detail__)"
    }
  },


  "manageFilesModal": {
    "title": "Manage files",
    "c1": {
      "title": "Filename"
    },
    "load": "Load",
    "delete": "Delete",
    "close": "Close",

    "confirmFileDeletion": "Confirm you really want to delete '__filename__' ?",

    "errors": {
      "cantRetrieveListOfFiles": "Can't retrieve the list of files. [__causedBy__]",
      "cantDeleteFile": "Can't delete '__filename__' file. [__causedBy__]"
    }
  },


  "settingsModal": {
    "title": "Settings",
    "language": "Language",
    "programmingStyle": "Programming style",
    "programmingStyleText": "Text (JavaScript)",
    "programmingStyleVisual": "Visual (Scratch-like)",
    "save": "Save",
    "cancel": "Cancel"
  },


  "importImagesModal": {
    "title": "Import images",
    "selectImage": "Select an image to use on the EV3:",
    "useDithering": "Use dithering ?",
    "keepAspectRatio": "Keep aspect ratio ?",
    "whiteBlackthreshold": "Threshold white to black",
    "selectCodeAndCopy": "If you want to use the image, select and copy the following code:",
    "close": "Close",

    "errors": {
      "fileIsNotAnImageSelectAnother": "'__filename__' cannot be read as an image, select a valid image file"
    }
  },

  
  "viewCodeModal": {
    "title": "Generated JavaScript code",
    "close": "Close"
  },  

  
  "ev3brick": {
    "ev3ConnectionOk": "EV3 Brick connection ok",
    "confirmStopScriptAlreadyRunning": "A script is already running, stop the script currently running and start the new script ?",

    "demo": {
      "no_connection_to_EV3": "Demo mode, some of the feature will not be available as Gnikrap is not running on an EV3 brick.",
      "no_run": "Demo mode, cannot run program",
      "no_stop_nor_shutdown": "Demo mode, nothing will be stopped/shutdown"
    },

    "errors": {
      "webSocketNotSupported": "WebSocket not supported by your Browser. Please try with a recent version of your browser. If not possible, please consider installing Firefox.",
      "ev3ConnectionFailed": "EV3 Brick connection failed. Connection will be retried in a few seconds. [__causedBy__]",
      "ev3ConnectionNok": "EV3 Brick connection closed by the EV3 brick. Connection will be retried in a few seconds.",
      "cantRunScriptEV3ConnectionNok": "Can't execute the script, the connection with the EV3 brick is down",
      "cantStopScriptEV3ConnectionNok": "Can't stop the script, the connection with the EV3 brick is down",
      "cantDoSomethingEV3ConnectionNok": "'__action__' cannot be done, the connection with the EV3 brick is down"
    }
  },


  "server": {
    "@comment": "Translation for the stuff coming from the server/brick",
    "errors": {
      "INVALID_MESSAGE_FIELD_FORMAT": "Field: '__field__' isn't of type text",
      "MESSAGE_FIELD_NOT_FOUND": "Can't found field: '__field__' in parameter message",
      "SCRITP_LANGUAGE_NOT_SUPPORTED": "Language: '__language__, isn't supported. Try JavaScript instead.",
      "UNKNOWN_ACTION": "No processor registered for action name: '__action__'",

      "INVALID_SENSOR_PORT": "Sensor port '__port__' isn't valid should be in [S1, S2, S3, S4] or [1, 2, 3, 4]",
      "INVALID_MOTOR_PORT": "Motor port '__port__' isn't valid, should be in [A, B, C, D]",
      "API_NOT_IMPLEMENTED": "The function __function__ isn't implemented",
      "INVALID_CHANNEL_VALUE": "Invalid channel value: '__channel__', valid values in [1, 2, 3, 4]",
      "INVALID_NOTE": "Invalid note: '__note__', should be in [C1-B7, # allowed on C, D, F, G, A] or [Do, Do#, Re, Re#, Mi, Fa, Fa#, Sol, Sol#, La, La#, Si]",
      "UNEXPECTED_ERROR": "Unexpected error: '__error__'",
      "SCRIPT_STOP_FORCED": "Script forced to stop, please use \"ev3.isOk()\"",
      "CANT_READ_FILE": "Can't read file '__filename__', technical error is: __error__",
      "IMAGE_CORRUPTED": "The image '__filename__' is corrupted (invalid file size)",
      "BAD_IMAGE_DATA": "The data provided to build the image is not correct (try to check that all the lines should have the same length)",
      "CANT_DECODE_IMAGE_INVALID_DATA_SIZE": "There is not enough data to decode an image with the following size: [__width__, __height__]",
      "CANT_DECODE_IMAGE": "The data provided is not correct for an image, reason: '__reason__'",
      "CANT_DECODE_IMAGE_INVALID_TYPE": "The type of the image provided is unknown: __type__"
    },
    "messages": {
      "SCRIPT_STARTING": "Script starting",
      "SCRIPT_ENDED": "Script ended"
    }
  },


  "aboutModal": {
    "gnikrapShortDescription": "<a href=\"http://jbenech.github.io/gnikrap/\" target=\"_blank\">Gnikrap</a> is a Scratch-like and JavaScript development environment for the <a href=\"http://www.lego.com/mindstorms/\" target=\"_blank\">Lego Mindstrom EV3</a>.",
    "softwareUsed": "This software has been made possible by using several open-source software:",
    "gnikrapLicence": "Licence (full text of the <a href=\"licence-lgpl-3.0.txt\" target=\"_blank\">GPL v3</a> licence):",
    "gplV3Notice": [
      "Gnikrap is a simple to use but powerfull JavaScript development ",
      "environment for the Lego Mindstrom EV3",
      "Copyright (C) 2014-2017 Jean BENECH",
      "",
      "This program is free software: you can redistribute it and/or modify",
      "it under the terms of the GNU General Public License as published by",
      "the Free Software Foundation, either version 3 of the License, or",
      "(at your option) any later version.",
      "",
      "This program is distributed in the hope that it will be useful,",
      "but WITHOUT ANY WARRANTY; without even the implied warranty of",
      "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
      "GNU General Public License for more details.",
      "",
      "You should have received a copy of the GNU General Public License",
      "along with this program. If not, see <a href=\"http://www.gnu.org/licenses/\" target=\"_blank\">http://www.gnu.org/licenses/</a>"
    ],
    "close": "Close"
  },

  
  "blocks": {
    "@comment": "Translation for blockly'blocks defined for Gnikrap",

    "categories": {
      "logic": "Logic",
      "loops": "Loops",
      "math": "Math",
      "text": "Text",
      "lists": "Lists",

      "ev3_brick": "EV3 brick",
      "sensors": "Sensors",
      "color_sensor": "Color sensor",
      "ir_sensor": "IR sensor",
      "touch_sensor": "Touch sensor",
      "keyboard": "Keyboard",
      "xSensors": "xSensors",
      "motors": "Motors",

      "variables": "Variables",
      "functions": "Functions",
      
      "advanced": "Advanced"
    },
    
    "errors": {
      "blockTwoDifferentSensorsOnTheSamePort": "There are two different sensors using the same port.",
      "blockTwoDifferentMotorsOnTheSamePort": "There are two different motor types defined for the same port.",
      "blockNeedToDefineMotorType": "Motor type is not defined for this port.",
      "blockXSensorValue": "All xSensors blocks must be inside a 'with the xSensor ... started do' block.",
      
      "compilePortWithSeveralMotorType": "ERROR: Port __port__ used with several motor types !",
      "compileMotorTypeNotDefineFor": "WARNING: Motor type not defined for port __port__. The motor type will be set by default to 'LargeMotor' for this port.",
      "compilePortUsedForSeveralSensor": "ERROR: Port __port__ used for several sensors types !",
      "compileXSensorMustBeInsideWithxSensorDo": "ERROR: All xSensors blocks must be inside a 'with the xSensor ... started do' block !"
    },

    "list_time_unit": {
      "S": "seconds",
      "MS": "milliseconds"
    },

    "list_speed_unit": {
      "DEGREE_PER_S": "degree(s)/second",
      "TURN_PER_S": "turn(s)/second",
      "PERCENT": "% power"
    },
        
    "gnikrap_ev3_notify": {
      "tooltip": "Display a message on the Gnikrap interface.",
      "text_notify": "notify"
    },

    "gnikrap_ev3_isok": {
      "tooltip": "Return true if everything is ok on the EV3 brick, false otherwise.",
      "text_ev3_is_ok": "EV3 is ok"
    },

    "gnikrap_ev3_stop": {
      "tooltip": "Stop the program.",
      "text_stop_script": "stop the program"
    },
    
    "gnikrap_ev3_wait_until": {
      "tooltip": "Wait until the condition was true.",
      "text_wait_until": "wait until"
    },

    "gnikrap_ev3_sleep": {
      "tooltip": "Make the program sleeping for the given time.",
      "text_sleep": "sleep"
    },

    "gnikrap_ev3_led": {
      "tooltip": "Change the LED status to the selected lightning pattern.",
      "list_change_LED_status": {
        "OFF": "change the LED status to off",
        "GREEN": "change the LED status to green",
        "GREEN_1": "change the LED status to flashing green",
        "GREEN_2": "change the LED status to fast flashing green",
        "ORANGE": "change the LED status to orange",
        "ORANGE_1": "change the LED status to flashing orange",
        "ORANGE_2": "change the LED status to fast flashing orange",
        "RED": "change the LED status to red",
        "RED_1": "change the LED status to flashing red",
        "RED_2": "change the LED status to fast flashing red"
      }
    },

    "gnikrap_ev3_sound_setvolume": {
      "tooltip": "Set the sound volume (between 0 and 100).",
      "text_set_volume": "set volume to"
    },

    "gnikrap_ev3_sound_beep": {
      "tooltip": "Play a beep.",
      "text_beep": "beep"
    },

    "gnikrap_ev3_sound_playnote": {
      "tooltip": "Play the given note (A, A#, B, C, C#, D, D#, E, F, F#, G, G#) for the given duration.",
      "text_play_note": "play note",
      "text_for": "for"
    },

    "gnikrap_ev3_touchsensor_pushed": {
      "tooltip": "Return true if the touch sensor is pushed, false otherwise.",
      "text_sensor": "sensor",
      "text_is_pushed": "is pushed"
    },

    "gnikrap_ev3_colorsensor_reflected": {
      "tooltip": "Return the reflected light: a value between 0 and 100.",
      "text_reflected_light": "reflected light of sensor"
    },

    "gnikrap_ev3_colorsensor_ambient": {
      "tooltip": "Return the ambient light: a value between 0 and 100.",
      "text_ambiant_light": "ambient light of sensor"
    },

    "gnikrap_ev3_colorsensor_getcolor": {
      "tooltip": "Return the color (in English) of the sensor.",
      "text_color": "color of sensor"
    },

    "gnikrap_ev3_colorsensor_iscolor": {
      "tooltip": "Return true if the color sensor 'view' the selected color, false otherwise.",
      "list_colors_detected": {
        "BLACK": "black is detected by sensor",
        "BLUE": "blue is detected by sensor",
        "YELLOW": "yellow is detected by sensor",
        "RED": "red is detected by sensor",
        "WHITE": "white is detected by sensor",
        "BROWN": "brown is detected by sensor",
        "NONE": "no color is detected by sensor"
      }
    },

    "gnikrap_ev3_irsensor_setchannel": {
      "tooltip": "Set the channel to use with the IR sensor.",
      "text_set_channel": "set channel",
      "text_to_sensor": "to IR sensor"
    },

    "gnikrap_ev3_irsensor_getdistance": {
      "tooltip": "Return the distance from the IR sensor: a value between 0 and 100.",
      "text_distance_to_sensor": "distance to IR sensor"
    },

    "gnikrap_ev3_irsensor_getremotecommand": {
      "tooltip": "Return true if the selected button of the remote beacon is pressed, false otherwise.",
      "list_beacon_buttons_enabled_on_sensor": {
        "TOP_LEFT": "top left button is enabled on IR sensor",
        "TOP_RIGHT": "top right button is enabled on IR sensor",
        "BOTTOM_LEFT": "bottom left button is enabled on IR sensor",
        "BOTTOM_RIGHT": "bottom right button is enabled on IR sensor",
        "BEACON": "beacon button is enabled on IR sensor",
        "NOTHING": "nothing is enabled on IR sensor"
      }
    },

    "gnikrap_ev3_keyboard_wait": {
      "tooltip": "Wait for a button to be pressed (and released is selected).",
      "list_keyboard_buttons_wait": {
        "UP": "wait up button",
        "DOWN": "wait down button",
        "LEFT": "wait left button",
        "RIGHT": "wait right button",
        "ENTER": "wait enter button",
        "ESCAPE": "wait escape button"
      },

      "list_keyboard_buttons_actions": {
        "PRESSED": "is pressed",
        "PRESSED_AND_RELEASED": "is pressed and released"
      }
    },

    "gnikrap_ev3_keyboard_ispressed": {
      "tooltip": "Return true if the button pressed, false otherwise.",
      "list_keyboard_buttons_is_pressed": {
        "UP": "up button is pressed",
        "DOWN": "down button is pressed",
        "LEFT": "left button is pressed",
        "RIGHT": "right button is pressed",
        "ENTER": "enter button is pressed",
        "ESCAPE": "escape button is pressed"
      }
    },

    "gnikrap_ev3_motor_settype": {
      "tooltip": "Set the type of motor on the given port.",
      "list_motor_type_connected_on": {
        "LARGE": "a large motor is connected on port",
        "MEDIUM": "a medium motor is connected on port"
      }
    },

    "gnikrap_ev3_motor_move": {
      "tooltip": "Start/stop the given motor. The program execution continue immediatly while the motor has taken in account the action.",
      "list_motor_actions": {
        "FORWARD": "rotate forward motor",
        "BACKWARD": "rotate backward motor",
        "STOP_LOCK": "stop and lock motor",
        "STOP": "stop motor"
      }
    },

    "gnikrap_ev3_motor_ismoving": {
      "tooltip": "Return true if the motor is moving, false otherwise.",
      "text_motor": "motor",
      "text_is_moving": "is moving"
    },

    "gnikrap_ev3_motor_rotate": {
      "tooltip": "Rotate the given motor for the given number of turn or degree. With 'start rotate', the program execution continue immediatly while the motor has taken in account the action. With 'rotate' the program wait the end of the move before going further.",
      "list_motor_actions": {
        "ROTATE": "rotate motor",
        "ROTATE_NO_WAIT": "start rotate motor"
      },
      "text_for": "for",
      "list_angle_unit": {
        "DEGREE": "degree(s)",
        "TURN": "turn(s)"
      }
    },

    "gnikrap_ev3_motor_setspeed": {
      "tooltip": "Set the speed of the motor.",
      "text_set_speed_of_motor": "set speed of motor",
      "text_to": "to"
    },

    "gnikrap_ev3_motor_getspeed": {
      "tooltip": "Return the speed of the motor.",
      "text_speed_of_motor": "speed of motor",
      "text_in": "in"
    },

    "gnikrap_ev3_motor_gettacho": {
      "tooltip": "Return the tacho count since the last 'reset tacho'.",
      "text_tacho_count_of_motor": "tacho count of motor"
    },

    "gnikrap_ev3_motor_resettacho": {
      "tooltip": "Reset the tacho count to 0.",
      "text_reset_tacho_count_of_motor": "reset tacho count of motor"
    },
    
    "gnikrap_ev3_xsensor_workwith": {
      "tooltip": "If the xSensor exist and is started execute the 'do' statements. Otherwise, the 'else' optional statements will be performed.",
      "text_with_the_xSensor": "with the xSensor",
      "text_started": "started",
      "text_do": "do",
      "text_else": "else"
    },
    
    "gnikrap_ev3_xgyro_getvalue": {
      "tooltip": "Return the angle value of the xGyro for the selected axis.",
      "list_axis_angle": {
        "X": "xGyro x axis angle",
        "Y": "xGyro y axis angle",
        "Z": "xGyro z axis angle"
      }    
    },
    
    "gnikrap_ev3_xgeo_getvalue": {
      "tooltip": "Return the value of the xGeo for the selected measure.",
      "list_measure": {
        "LATITUDE": "xGeo latitude",
        "LONGITUDE": "xGeo longitude", 
        "ACCURACY": "xGeo accuracy", 
        "ALTITUDE": "xGeo altitude",
        "ALTITUDE_ACCURACY": "xGeo altitude accuracy",
        "TIMESTAMP": "xGeo timestamp"
      }
    },
    
    "gnikrap_ev3_xvideo_containsobject": {
      "tooltip": "Return true if the object with the given name currently tracked by the xVideo sensor, false otherwise.",
      "text_xVideo_known_the_object": "xVideo knows the object"
    },
    
    "gnikrap_ev3_xvideo_getvalue": {
      "tooltip": "Return for the given object the value of the selected coordinate.",
      "list_axis_for_object": {
        "X": "xVideo x value for the object",
        "Y": "xVideo y value for the object"
      }
    },
    
    "gnikrap_ev3_xtouch_istouchpressed": {
      "tooltip": "Return true if the given touch is pressed, false otherwise.",
      "text_xTouch_touch": "xTouch touch",
      "text_is_pressed": "is pressed"
    }
  },
  
  "autocompletion": {
    "js": { 
      "keywords": [""],
      "score": 120,
      "words": ["break", "case", "catch", "continue", "default", "do", "else", "false", "finally", "for", "function", "if", "in",
                "new", "null", "return", "switch", "true", "try", "var", "while", "ev3"]
    },
    "ev3": { 
      "keywords": ["ev3"],
      "score": 120,
      "words": ["isOk()", "getBrick()", "notify(\"text\")", "sleep(0)", "getConfiguration()", "getXSensor(\"name\")"]
    },
    "brick": { 
      "keywords": ["brick", "getBrick"],
      "score": 110,
      "words": ["getMediumMotor(\"A\")", "getLargeMotor(\"A\")", "getColorSensor(\"1\")", "getIRSensor(\"1\")", "getTouchSensor(\"1\")",
                "getKeyboard()", "getLed()", "getSound()", "getScreen()", "getBattery()", "getNXTSoundSensor(\"1\")", "getUltrasonicSensor(\"1\")"]
    },
    "motor": { 
      "keywords": ["motor", "getMediumMotor", "getLargeMotor"],
      "score": 100,
      "words": ["forward()", "backward()", "stop()", "stop(true|false)", "stop(true|false, true|false)", "rotate(0)", "rotate(0, true|false)",
                "isMoving()", "getTachoCount()", "resetTachoCount()", "setSpeedPercent(50)", "getSpeedPercent()", "setSpeed(360)", "getSpeed()"]
    },
    "color": { 
      "keywords": ["color", "getColorSensor"],
      "score": 90,
      "words": ["getReflectedLight()", "getAmbientLight()", "getColor()",
                "getValue()", "isNoColor()", "isBlack()", "isBlue()", "isYellow()", "isRed()", "isWhite()", "isBrown()", "getColorAsText()"]
    },
    "IR": { 
      "keywords": ["ir", "getIRSensor", "infra", "infrared"],
      "score": 80,
      "words": ["setChannel(1)", "getChannel()", "getDistance()", "getRemoteCommand()", "seekBeacon()"]
    },
    "IR RC": { 
      "keywords": ["ir", "getIRSensor", "getRemoteCommand", "remote", "command"],
      "score": 80,
      "words": ["getValue()", "isTopLeftEnabled()", "isTopRightEnabled()", "isBottomLeftEnabled()", "isBottomRightEnabled()", 
                "isBeaconEnabled()", "isNothingEnabled()"]
    },
    "IR SB": {
      "keywords": ["ir", "getIRSensor", "seekBeacon", "beacon"],
      "score": 80,
      "words": ["isBeaconFound()", "getBearing()", "getDistance()", "isBeaconFound(0)", "getBearing(0)", "getDistance(0)"]
    },
    "touch": { 
      "keywords": ["touch", "getTouchSensor"],
      "score": 70,
      "words": ["isPushed()"]
    },
    "keyboard": { 
      "keywords": ["keyboard", "getKeyboard"],
      "score": 50,
      "words": ["getDown()", "getEnter()", "getEscape()", "getLeft()", "getRight()", "getUp()", "waitForAnyPress()", "isUp()", 
                "isDown()", "waitForPress()", "waitForPressAndRelease()", "getId()"]
    }, 
    "led": { 
      "keywords": ["led", "getLed"],
      "score": 40,
      "words": ["off()", "lightGreen()", "lightRed()", "lightOrange()", "blink()"]
    },
    "sound": {
      "keywords": ["sound", "getSound"],
      "score": 30,
      "words": ["setVolume(50)", "getVolume()", "beep()", "playTone(440, 100)", "playNote(\"Do\", 100)"]
    },
    "screen": {
      "keywords": ["screen", "getScreen"],
      "score": 20,
      "words": ["clear()", "drawText(\"Text\", x, y)", "drawText(\"Text\", x, y, true)", "drawLine(x1, y1, x2, y2)", 
                "drawRectangle(x1, y1, x2, y2)", "fillRectangle(x1, y1, x2, y2)", "drawCircle(x, y, radius)",
                "fillCircle(x, y, radius)", "drawArc(x, y, width, height, startAngle, arcAngle)", "fillArc(x, y, width, height, startAngle, arcAngle)",
                "getWidth()", "getHeight()", "getFontHeight()", "drawImage(img, x, y)", "decodeImage(data)", "buildImage(line1, line2, ..., lineN)"]
    },
    "battery": {
      "keywords": ["battery", "getBattery"],
      "score": 10,
      "words": ["getBatteryCurrent()", "getMotorCurrent()", "getVoltageMilliVolt()"]
    },
    "NXTSound": {
      "keywords": ["NXTSound", "getNXTSoundSensor", "sound"],
      "score": 5,
      "words": ["getDBA()", "getDB()"]
    },
    "ultrasonic": {
      "keywords": ["ultrasonic", "getUltrasonicSensor"],
      "score": 4,
      "words": ["getDistance()", "isUltrasonicDetected()"]
    },
    "xSensor": {
      "keywords": ["xSensor", "getXSensor"],
      "score": 60,
      "words": ["getName()", "getValue()", "isStarted()"]
    },
    "xTouch": {
      "keywords": ["xSensor", "getXSensor"],
      "score": 60,
      "words": ["containsTouch(\"name\")", "getTouch(\"name\")", "getTouches()", "getName()", "getHits()"]
    },
    "xGyro": {
      "keywords": ["xSensor", "getXSensor"],
      "score": 60,
      "words": ["getX()", "getY()", "getZ()", "getAngle()"]
    },
    "xVideo": {
      "keywords": ["xSensor", "getXSensor"],
      "score": 60,
      "words": ["containsObject(\"name\")", "getObject(\"name\")", "getObjects()", "getName()", "getX()", "getY()"]
    },
    "xGeo": {
      "keywords": ["xSensor", "getXSensor"],
      "score": 60,
      "words": ["getTimestamp()", "getLatitude()", "getLongitude()", "getAccuracy()", "getAltitude()", "getAltitudeAccuracy()"]
    }
  }
}
